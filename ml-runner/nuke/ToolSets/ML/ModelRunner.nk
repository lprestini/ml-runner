Group {
 name ModelRunner1
 knobChanged "_node = nuke.thisNode()\nis_semantic = _node\[\"use_gdino\"].value()\nis_segmentation = _node\['model_to_run'].value()  in ('sam','dam')\nis_tracking = _node\['model_to_run'].value() == 'cotracker'\npasses_knobs = \['all_passes','albedo','roughness','metallic','normal','irradiance']\nsegment_knobs = \['crop_position', 'id_class','frame_idx','fetch_frame','use_gdino']\ntracker_knob = \['grid_size', 'use_grid','crop_position','frame_idx','fetch_frame']\nlimit_range_knobs = \['limit_first','limit_last']\nif _node\['use_limit'].value():\n    \[_node\[i].setVisible(True) for i in limit_range_knobs]\nelse:\n    \[_node\[i].setVisible(False) for i in limit_range_knobs]\n\nif is_segmentation:\n    if _node\['all_passes'].visible():\n        \[_node\[i].setVisible(False) for i in passes_knobs]\n    if _node\['use_grid'].visible():\n        \[_node\[i].setVisible(False) for i in tracker_knob if not i in segment_knobs]\n\n    \[_node\[i].setVisible(True) for i in segment_knobs]\n    if is_semantic: \n        _node\['crop_position'].setVisible(False)\n        _node\['id_class'].setVisible(True)\n    else:\n        _node\['crop_position'].setVisible(True)\n        _node\['id_class'].setVisible(False)\nelif is_tracking:\n    \[_node\[i].setVisible(False) for i in segment_knobs]\n    if _node\['all_passes'].visible():\n        \[_node\[i].setVisible(False) for i in passes_knobs]\n    \[_node\[i].setVisible(True) for i in tracker_knob]\n    if _node\['use_grid'].value():\n        _node\['crop_position'].setVisible(False)\n    if _node\['grid_size'].value() > _node\['max_grid_value'].value():\n        _node\['grid_size'].setValue(_node\['max_grid_value'].value())\nelse:\n    \[_node\[i].setVisible(False) for i in segment_knobs]\n    \[_node\[i].setVisible(False) for i in tracker_knob]\n    if _node\['model_to_run'].value() == 'rgb2x':\n        _node\[passes_knobs\[0]].setVisible(True)\n        if not _node\['all_passes'].value():\n            \[_node\[i].setVisible(True) for i in passes_knobs]\n        else:\n            \[_node\[i].setVisible(False) for i in passes_knobs\[1:]]\n    else:\n        \[_node\[i].setVisible(False) for i in passes_knobs]"
 selected true
 xpos 792
 ypos -103
 addUserKnob {20 User}
 addUserKnob {26 configtext l "Server settings"}
 addUserKnob {1 config_save_directory l "Server listenting directory"}
 config_save_directory /tmp/
 addUserKnob {26 text_5 l "     " T "   "}
 addUserKnob {26 configtext1 l "Config settings"}
 addUserKnob {1 path_to_sequence l "Path to sequence" t "path to sequence directory to run"}
 path_to_sequence /path/to/some/sequence
 addUserKnob {1 shot_name l "shot name" t "Name of the shot to run model on" -STARTLINE}
 shot_name some_shot.%04d.png
 addUserKnob {22 fetch_shot_and_path l "Fetch Path & Shot" -STARTLINE T "def get_upstream_read_node(n):\n    if n is None:\n      nuke.critical(\"Supplied node is None\")\n    if n.Class() == 'Read':\n      return n\n    for input_no in range(n.inputs()):\n      up_n = get_upstream_read_node(n.input(input_no))\n      if not up_n is None:\n        return up_n\n    return None\n\n\nthis = nuke.thisNode()\nnode = get_upstream_read_node(this)\npath_to_seq = os.path.dirname(node\['file'].evaluate())\nshot_name = os.path.basename(node\['file'].value())\next = os.path.splitext(shot_name)\[-1]\next_match = ext == '.exr' or ext == '.png' or ext == '.jpg'\n\n\nif ext_match:\n    delimiter = shot_name.split('%')\[0]\[-1]if '%' in shot_name else shot_name.split('\\#')\[0]\[-1]\n\n\n    this\['path_to_sequence'].setValue(path_to_seq)\n    this\['shot_name'].setValue(shot_name)\n    this\['delimiter'].setValue(delimiter)\nelse:\n    nuke.alert(f'Hey - I dont support \{ext\} file format. Try with png/exr')"}
 addUserKnob {6 use_limit l "limit range" +STARTLINE}
 addUserKnob {3 limit_first l "first frame" -STARTLINE +HIDDEN}
 limit_first 1
 addUserKnob {3 limit_last l "last frame" -STARTLINE +HIDDEN}
 limit_last 30
 addUserKnob {1 delimiter t "File convention to split between name and frame number. "}
 delimiter .
 addUserKnob {1 render_to l "render to"}
 render_to /tmp/tst
 addUserKnob {1 render_name l "render name" t "This can simply be the name. \nNo need for file extension/frame padding as it will copy whatever you have on your input sequence" -STARTLINE}
 render_name some_name
 addUserKnob {26 text_3 l "  " T " "}
 addUserKnob {26 text_1 l "Model parameters" T "\n"}
 addUserKnob {26 text l " " -STARTLINE}
 addUserKnob {4 model_to_run l "Model to run" t "Sam - SegmentAnything2 (META)\nDAM -  DistractorAwareMemory for SAM2" M {sam dam depth_crafter rgb2x cotracker "" ""}}
 addUserKnob {6 use_grid l "track everything" -STARTLINE +HIDDEN}
 addUserKnob {6 use_gdino l "Use semantic detection" t "If enabled, it will try to find in the reference frame the id class defined by the user." -STARTLINE}
 addUserKnob {3 grid_size l "grid size" t "Number of points to spawn in grid. Capped at 40x40" +HIDDEN}
 grid_size 40
 addUserKnob {3 max_grid_value +INVISIBLE}
 max_grid_value 40
 addUserKnob {1 id_class l "id class" t "What to segment when using semantic detection" +HIDDEN}
 addUserKnob {15 crop_position l "crop position"}
 crop_position {0 0 500 500}
 addUserKnob {3 frame_idx l "reference frame"}
 frame_idx 30
 addUserKnob {22 fetch_frame l "fetch frame" -STARTLINE T "frame = nuke.frame() if nuke.frame() >= nuke.thisNode()\['firstFrame'].value() else nuke.thisNode()\['firstFrame'].value()\nframe = frame if frame <= nuke.thisNode()\['lastFrame'].value() else nuke.thisNode()\['lastFrame'].value()\nframe = int(frame)\nnuke.thisNode()\['frame_idx'].setValue(frame)"}
 addUserKnob {6 all_passes l "all passes" +HIDDEN +STARTLINE}
 all_passes true
 addUserKnob {6 albedo -STARTLINE +HIDDEN}
 addUserKnob {6 normal -STARTLINE +HIDDEN}
 addUserKnob {6 roughness +HIDDEN +STARTLINE}
 addUserKnob {6 metallic -STARTLINE +HIDDEN}
 addUserKnob {6 irradiance -STARTLINE +HIDDEN}
 addUserKnob {22 addcrop l "add crop" +INVISIBLE +STARTLINE}
 addUserKnob {3 firstFrame l integer +INVISIBLE}
 firstFrame {{input.first_frame}}
 addUserKnob {3 lastFrame l integer -STARTLINE +INVISIBLE}
 lastFrame {{input.last_frame}}
 addUserKnob {26 ""}
 addUserKnob {22 writeconfig l "write config" t "Write config file to server listening location" T "import json\nimport os\nimport uuid\nimport nuke\nimport nukescripts\nimport time\n\n\nif nuke.NUKE_VERSION_MAJOR > 15:\n    from PySide6 import QtWidgets, QtGui\n    # from PySide6.QtWidgets import QPushButton, QSizePolicy\n    from PySide6.QtCore import Qt, QObject, QEvent\nelse:\n    from PySide2 import QtWidgets, QtGui\n    from PySide2.QtCore import Qt, QObject, QEvent\n\n\nclass UserActivityMonitor(QObject):\n    def __init__(self, idle_timeout=1):  # milliseconds\n        super().__init__()\n        self.last_activity_time = time.time()\n        self.idle_timeout = idle_timeout / 1000  # convert to seconds\n\n\n    def eventFilter(self, obj, event):\n        if event.type() in (QEvent.KeyPress, QEvent.MouseMove, QEvent.MouseButtonPress):\n            self.last_activity_time = time.time()\n        return super().eventFilter(obj, event)\n\n\n    def is_user_idle(self):\n        return (time.time() - self.last_activity_time) > self.idle_timeout\n\n\nclass CustomTimer(threading.Thread):\n    def __init__(self, interval, function, args=None, kwargs=None):\n        super().__init__()\n        self.interval = interval\n        self.function = function\n        self.args = args or \[]\n        self.kwargs = kwargs or \{\}\n        self._stop_event = threading.Event()\n        self.has_created = False\n\n\n    def run(self):\n        if not self._stop_event.wait(self.interval):\n            self.has_created = self.function(*self.args, **self.kwargs)\n        if self.has_created:\n            self.cancel()\n\n\n    def cancel(self):\n        self._stop_event.set()\n\n\nclass Loader(object):\n    def __init__(self, node, path, print_to_terminal = True, is_tracker = False):\n        self.node = node\n        self.path = path\n        self.print_to_terminal = print_to_terminal\n        self.is_tracker = is_tracker\n        self.timer = CustomTimer(10, self.load_bg_render, \[self.node, self.path, self.print_to_terminal, self.is_tracker],)\n        self.timer.start()\n        self.timer_completed = False\n        self.user_monitor = UserActivityMonitor()\n        app = QtWidgets.QApplication.instance()\n        app.installEventFilter(self.user_monitor)\n\n\n    def setup_read(self, file_list, node):\n        \"\"\"Function to create the read node. Have to use this as a workaround as I cant simply do nuke.nodes.Read() with threading.Timer as it crashes nuke\"\"\"\n\n\n        reads = \[i for i in nuke.allNodes('Read')]\n        read_no = max(\[int(i\['name'].value().replace('Read','')) for i in reads if 'MLRunner' not in i.name()]) + 1\n        template_node = \"\"\"Read \{\n            name template_name\n            file template_file\n            first template_first\n            last template_last\n            file_type png\n            xpos template_xpos\n            ypos template_ypos\n            \}\"\"\"\n        name, frame_range = file_list.split(' ')\n        first,last = frame_range.split('-')\n        xpos = node.xpos() + 150\n        ypos = node.ypos()\n        template_node = template_node.replace('template_file',name).replace('template_first', first).replace('template_last', last).replace('template_name','Read' + str(read_no)).replace('template_xpos', str(xpos)).replace('template_ypos', str(ypos))\n        nuke.tcl('in root \{%s\}' % template_node)\n\n\n    def load_bg_render(self, node, path, print_to_terminal, is_tracker):\n        if not self.timer_completed:\n            self.timer = CustomTimer(10, self.load_bg_render, \[self.node, self.path, self.print_to_terminal, self.is_tracker],)\n            self.timer.start()\n        else:\n            self.timer.cancel()\n\n\n        if os.path.isfile(self.path):\n            # Read json\n            with open(self.path,'r') as f:\n                file = json.load(f)\n            name = file\['name']\n            tracking = file\['tracking_progress']\n            render_p = file\['render_progress']\n            filename = file\['filename']\n            error = file\['error']\n            cancelled = file\['is_cancelled']\n\n\n            # Check if file is the first in queue\n            queue = self.node\['queue'].value().split(',')\n            queue = queue if len(queue) >= 1 else \[name]\n            correct_queue = True if name == queue\[0] else False\n            self.timer_completed = False\n\n\n            # Update progress\n            if correct_queue:\n                # This is a little buggy as nuke UI doens't always update \n                filler = f'name: \{name\}\\ntracking progress: \{tracking\}\\nrender_progress: \{render_p\}'\n                self.node\['render_progress'].setValue(filler)\n                if self.print_to_terminal:\n                    nuke.tprint(filler)\n\n\n            # Stop timer\n            if render_p == '100%' or error or cancelled:\n                # timer.cancel()\n                queue = self.node\['queue'].value().split(',')\n                queue.pop(0)\n                self.node\['queue'].setValue(','.join(i for i in queue))\n                os.remove(self.path)\n                self.timer_completed = True\n                # Need to implement error behaviour\n\n\n            # Load rendered element in nuke\n            if self.timer_completed and not error and not cancelled:\n                # Need to check if user is doing stuf as it can crash nuke if we create nodes while user interacts with UI\n                max_count = 40\n                count = 0\n                while count <= max_count:\n                    if self.user_monitor.is_user_idle():\n                        if not self.is_tracker:\n                            if self.user_monitor.is_user_idle():\n                                for _file in filename:\n                                    shot = \[i for i in nuke.getFileNameList(os.path.dirname(self.path)) if _file in i]\n                                    if shot:\n                                        self.setup_read(os.path.join(os.path.dirname(self.path),shot\[0]).replace('\\\\','/'), self.node)\n                                count = 40\n                        else:\n                            if self.user_monitor.is_user_idle():\n                                for _file in filename:\n                                    with open(os.path.join(os.path.dirname(self.path), _file), 'r') as f:\n                                        nuke.tcl('in root \{%s\}' % f.read())\n                                count = 40\n                    count +=1\n                    \n        return self.timer_completed\n\n\ndef ensure_legal_crop_size(crop_val, width, height):\n    box = \[]\n    for idx, i in enumerate(crop_val):\n        if i <0: \n            i = 0\n        elif i > width and idx == 2:\n            i = width\n        elif i > height and idx == 3:\n            i = height\n        box.append(i)\n    return box\n\n\ndef ensure_legal_frame(current_frame, first, last):\n    frame = current_frame if current_frame > first else first\n    frame = current_frame if current_frame < last else last \n    return frame\n\n\ndef padding_to_num(padded_name, delimiter, ref_frame):\n    pad, ext = os.path.splitext(padded_name)\n    pad = pad.split(delimiter)\[-1]\n    pad = pad.replace('%0','').replace('d','')\n    pad = int(pad) - len(str(ref_frame))\n    pads = ''.join('0' for i in range(int(pad)))\n    return pads\n\n\nnode = nuke.thisNode()\nconfig_save_directory = node\['config_save_directory'].value()\nshot_name = node\['shot_name'].value()\nwidth = node.width()\nheight = node.height()\ndelimiter = node\['delimiter'].value()\nframe_idx = int(node\['frame_idx'].value()) #ensure_legal_frame(int(node\['frame_idx'].value()), int(node.firstFrame()), int(node.lastFrame()))\n\n\n# Check all is good\nis_correct_extension = any(shot_name.split('.')\[-1].lower() in i for i in ('.png','.jpg', '.jpeg', '.exr'))\npath_to_sequence_exists = os.path.isdir(node\['path_to_sequence'].value())\nis_node_connected = len(node.dependencies()) > 0\nis_segmentation = node\['model_to_run'].value() in ('sam','dam')\nis_tracking = node\['model_to_run'].value() == 'cotracker'\n\n\nif is_segmentation or is_tracking:\n    is_frame_legal = frame_idx >= int(node.firstFrame()) and frame_idx <= int(node.lastFrame())\n    if node\['use_limit'].value():\n        is_frame_legal = frame_idx >= int(node\['limit_first'].value()) and frame_idx <= int(node\['limit_last'].value())\nelse:\n    frame_idx = int(node.firstFrame()) if not node\['use_limit'].value() else int(node\['limit_first'].value()) \n    is_frame_legal = True\n    \nconfig_dir_exists = os.path.isdir(config_save_directory) \nis_server_running = os.path.isfile(os.path.join(config_save_directory,'.server_is_running.tmp').replace('\\\\','/')) \n\n\nall_good = False\nif all(i for i in (is_correct_extension, path_to_sequence_exists, is_node_connected, is_frame_legal, config_dir_exists, is_server_running)):\n    all_good = True\nelse:\n    errors = \[idx for idx,i in enumerate((is_correct_extension, path_to_sequence_exists, is_node_connected, is_frame_legal, config_dir_exists, is_server_running)) if not i]\n    error_keys = \['unsupported_extension', 'wrong_path', 'node_not_connected', 'wrong_frame', 'wrong_config_path', 'server_not_running']\n\n\nerror_messages = \{\n    'unsupported_extension' : 'ERROR! The sequence you are trying to run does not have the correct file extension. We only support png and jpg for now.\\n',\n    'wrong_path'            : 'ERROR! The path to the sequence doesnt seem to exists. Please check for spelling mistakes or use the Fetch Path shot button\\n',\n    'node_not_connected'    : 'ERROR! Please connect the node to the sequence you want to run\\n',\n    'wrong_frame'           : 'ERROR! The reference frame is outside the range of the sequence\\n',\n    'wrong_config_path'     : f\"ERROR! The path defined in the Server listenting directory knob doesn't seem to exist! Please check for spelling mistakes!\\n \{config_save_directory\}\\n\",\n    'server_not_running'    : f\"ERROR! The server does't seem to be running. \\nPlease contact your administrator or ensure that the server is listenting in the same directory as what's specified in the node:\\n\{config_save_directory\}\\n\",\n\}\n\n\nif all_good:\n    crop_position = ensure_legal_crop_size(node\['crop_position'].value(), width, height)\n    ## Setup config file\n    config = \{\}\n    config\['listen_dir']   = config_save_directory\n    config\['model_to_run'] = node\['model_to_run'].value()\n    config\['id_class'] = node\['id_class'].value() \n    config\['crop_position'] = \[crop_position]\n    config\['path_to_sequence'] = node\['path_to_sequence'].value()\n    config\['shot_name'] = shot_name\n    config\['render_to'] = node\['render_to'].value()\n    config\['render_name'] = node\['render_name'].value()\n    config\['use_gdino'] = node\['use_gdino'].value()\n    config\['frame_idx'] = int(frame_idx - node.firstFrame())\n    config\['first_frame_sequence'] = int(node.firstFrame())\n    config\['limit_range'] = node\['use_limit'].value()\n    config\['delimiter'] = delimiter\n    config\['use_grid'] = node\['use_grid'].value()\n    config\['grid_size'] = node\['grid_size'].value()\n    config\['colourspace'] = 'linear' if node\['model_to_run'].value() == 'rgb2x' else 'srgb'\n    config\['passes'] = \['albedo','roughness','metallic','normal','irradiance']\n    if not node\['all_passes'].value():\n        pass_knobs = config\['passes']\n        config\['passes'] = \[i for i in pass_knobs if node\[i].value() == True]\n\n\n    # Not implemented yet\n    config\['multisequence'] = False\n\n\n    # We remove one frame as we are using these to simply slice lists\n    config\['limit_first'] = int(node\['limit_first'].value() - node.firstFrame())\n    config\['limit_last'] = int(node\['limit_last'].value() - node.firstFrame()) + 1\n\n\n    # Write related stuff\n    write_sequence = node\['write_sequence'].value()\n    write = nuke.toNode(f'\{node.name()\}.Write1')\n    # Workaround to evaluate padding\n    write\['file'].setValue(shot_name)\n    shot_name_no_padding = os.path.basename(write\['file'].evaluate())\n\n\n    ## When using pipelines evaluate is returning the path of the sequence. This is a hacky workaround.\n    if os.path.isdir(shot_name_no_padding):\n        shot_name_no_padding = padding_to_num(shot_name, delimiter, int(frame_idx))\n    config\['shot_name'] = shot_name_no_padding\n\n\n    if not os.path.isdir(config\['render_to']):\n        os.makedirs(config\['render_to'])\n\n\n    # If render sequence we write to path_to_sequence\n    if write_sequence:\n        write\['file'].setValue(os.path.join(node\['path_to_sequence'].value(), shot_name).replace('\\\\','/'))\n        nukescripts.render_panel((nuke.thisNode(),), False)\n\n\n    ## Write config\n    unique_name = str(uuid.uuid4())\n    config\['uuid'] = unique_name\n    with open(os.path.join(config_save_directory, f'\{unique_name\}_\{shot_name_no_padding\}.json').replace('\\\\','/'), 'w') as f:\n        json.dump(config, f, indent = 4)\n\n\n    queue = node\['queue'].value()\n    queue = queue + ',' + unique_name if queue != '' else unique_name\n    node\['queue'].setValue(queue)\n    node_loader = Loader(node, os.path.join(config\['render_to'], f'\{unique_name\}_render_progress.json').replace('\\\\','/'), is_tracker = is_tracking)\nelse:\n    error_message = '\\n'.join(error_messages\[error_keys\[i]] for i in errors )\n    nuke.alert(f'The following errors where found. Please ensure they are all fixed prior to writing the config:\\n\{error_message\}')\n\n" +STARTLINE}
 addUserKnob {6 write_sequence -STARTLINE +INVISIBLE}
 addUserKnob {22 cancel_render l "cancel render" t "Interrupts model processing" -STARTLINE T "import json\nimport os\nimport uuid\nimport nuke\nimport nukescripts\n\n\n\nnode = nuke.thisNode()\nconfig_save_directory = node\['render_to'].value()\n\n\n\nwith open(os.path.join(config_save_directory, 'cancel_render'),'w') as f:\n    f.write('cancel')"}
 addUserKnob {26 render_progress l "Background progress" T "name: none\ntracking progress: 0%\nrender_progress: 0%"}
 addUserKnob {1 queue +INVISIBLE}
}
 Input {
  inputs 0
  name Input1
  xpos 486
  ypos -268
 }
 Write {
  file some_shot.%04d.png
  file_type png
  create_directories true
  checkHashOnRead false
  version 10
  in_colorspace scene_linear
  out_colorspace scene_linear
  ocioColorspace scene_linear
  display default
  view sRGB
  name Write1
  xpos 390
  ypos -160
 }
 Output {
  name Output1
  xpos 390
  ypos -60
 }
end_group
