Group {
name ModelRunner1
knobChanged "\n_node = nuke.thisNode()\nis_semantic = _node\[\"use_gdino\"].value()\nmodel_to_run = _node\['model_to_run'].value()\ntext_sam3 = _node\[\"use_sam3\"].value()\nis_segmentation = model_to_run  in ('sam','dam','sam3')\nis_gs = model_to_run == 'ml-sharp'\nis_tracking = model_to_run == 'cotracker'\nframe_knobs = \['frame_idx', 'fetch_frame']\npasses_knobs = \['all_passes','albedo','roughness','metallic','normal','irradiance']\nsegment_knobs = \['crop_position', 'id_class','use_gdino']\ntracker_knob = \['grid_size', 'use_grid','crop_position']\ngs_knobs = \['film_back_size', 'single_frame_mode', 'focal_lenght']\nlimit_range_knobs = \['limit_first','limit_last']\nif _node\['use_limit'].value():\n    \[_node\[i].setVisible(True) for i in limit_range_knobs]\nelse:\n    \[_node\[i].setVisible(False) for i in limit_range_knobs]\nif not is_gs:\n    _node\['single_frame_mode'].setValue(False)\nif is_segmentation:\n    _node\[\"use_sam3\"].setVisible(False)\n    \n    if _node\['all_passes'].visible():\n        \[_node\[i].setVisible(False) for i in passes_knobs]\n    if _node\['use_grid'].visible():\n        \[_node\[i].setVisible(False) for i in tracker_knob if not i in segment_knobs]\n    if _node\['focal_lenght'].visible():\n        \[_node\[i].setVisible(False) for i in gs_knobs]\n\n    \[_node\[i].setVisible(True) for i in segment_knobs]\n    \[_node\[i].setVisible(True) for i in frame_knobs]\n\n    if is_semantic: \n        _node\['crop_position'].setVisible(False)\n        _node\['id_class'].setVisible(True)\n    else:\n        _node\['crop_position'].setVisible(True)\n        _node\['id_class'].setVisible(False)\n        \n    if model_to_run == 'sam3':\n        _node\[\"use_gdino\"].setVisible(False)\n        _node\[\"use_gdino\"].setValue(False)\n        _node\['crop_position'].setVisible(False)\n        _node\['id_class'].setVisible(True)\n    else:\n        _node\[\"use_gdino\"].setVisible(True)\n        \nelif is_tracking:\n    \[_node\[i].setVisible(False) for i in segment_knobs]\n    \[_node\[i].setVisible(True) for i in frame_knobs]\n    if _node\['focal_lenght'].visible():\n        \[_node\[i].setVisible(False) for i in gs_knobs if not i in tracker_knob]\n    if _node\['all_passes'].visible():\n        \[_node\[i].setVisible(False) for i in passes_knobs]\n    \[_node\[i].setVisible(True) for i in tracker_knob]\n    if _node\['use_grid'].value():\n        _node\['crop_position'].setVisible(False)\n    if _node\['grid_size'].value() > _node\['max_grid_value'].value():\n        _node\['grid_size'].setValue(_node\['max_grid_value'].value())\n\nelif is_gs:\n    \[_node\[i].setVisible(False) for i in segment_knobs]\n    \[_node\[i].setVisible(False) for i in tracker_knob] \n    if _node\['all_passes'].visible():\n        \[_node\[i].setVisible(False) for i in passes_knobs]\n    \[_node\[i].setVisible(True) for i in gs_knobs]\n    \[_node\[i].setVisible(False) for i in frame_knobs]\n    if _node\['single_frame_mode'].value():\n        \[_node\[i].setVisible(True) for i in frame_knobs]\nelse:\n    \[_node\[i].setVisible(False) for i in gs_knobs]\n    \[_node\[i].setVisible(False) for i in segment_knobs]\n    \[_node\[i].setVisible(False) for i in tracker_knob]\n    if _node\['model_to_run'].value() == 'rgb2x':\n        _node\[passes_knobs\[0]].setVisible(True)\n        if not _node\['all_passes'].value():\n            \[_node\[i].setVisible(True) for i in passes_knobs]\n        else:\n            \[_node\[i].setVisible(False) for i in passes_knobs\[1:]]\n    else:\n        \[_node\[i].setVisible(False) for i in passes_knobs]"
selected true
xpos -701
ypos 57
addUserKnob {20 User}
addUserKnob {26 configtext l "Server settings"}
addUserKnob {1 config_save_directory l "Server listenting directory"}
config_save_directory /tmp/
addUserKnob {26 text_5 l "     " T "   "}
addUserKnob {26 configtext1 l "Config settings"}
addUserKnob {1 path_to_sequence l "Path to sequence" t "path to sequence directory to run"}
path_to_sequence /path/to/some/sequence
addUserKnob {1 shot_name l "shot name" t "Name of the shot to run model on" -STARTLINE}
shot_name some_shot.%04d.png
addUserKnob {22 fetch_shot_and_path l "Fetch Path & Shot" -STARTLINE T "def get_upstream_read_node(n):\n    if n is None:\n      nuke.critical(\"Supplied node is None\")\n    if n.Class() == 'Read':\n      return n\n    for input_no in range(n.inputs()):\n      up_n = get_upstream_read_node(n.input(input_no))\n      if not up_n is None:\n        return up_n\n    return None\n\n\nthis = nuke.thisNode()\nnode = get_upstream_read_node(this)\npath_to_seq = os.path.dirname(node\['file'].evaluate())\nshot_name = os.path.basename(node\['file'].value())\next = os.path.splitext(shot_name)\[-1]\next_match = ext == '.exr' or ext == '.png' or ext == '.jpg' or ext == '.mov'\n\n\nif ext_match:\n    delimiter = shot_name.split('%')\[0]\[-1]if '%' in shot_name else shot_name.split('\\#')\[0]\[-1]\n    splitter = '/plate' if 'plate' in path_to_seq else '/element'\n    splitter = splitter if 'element' in path_to_seq else ''\n    if splitter == '':\n        render_to = os.path.join(os.path.dirname(path_to_seq),'elements', os.path.basename(os.path.dirname(path_to_seq)) + '_ML_Runner')\n    else:\n        render_to = path_to_seq.split(splitter)\[0] \n        render_to = os.path.join(render_to, 'elements', os.path.basename(render_to) + '_ML_Runner')\n\n    this\['path_to_sequence'].setValue(path_to_seq)\n    this\['shot_name'].setValue(shot_name)\n    this\['delimiter'].setValue(delimiter)\n    this\['render_to'].setValue(render_to)\nelse:\n    nuke.alert(f'Hey - I dont support \{ext\} file format. Try with png/exr')"}
addUserKnob {6 use_limit l "limit range" +STARTLINE}
addUserKnob {3 limit_first l "first frame" -STARTLINE +HIDDEN}
limit_first 1
addUserKnob {3 limit_last l "last frame" -STARTLINE +HIDDEN}
limit_last 30
addUserKnob {1 delimiter t "File convention to split between name and frame number. "}
delimiter .
addUserKnob {1 render_to l "render to"}
render_to /tmp/tst
addUserKnob {1 render_name l "render name" t "This can simply be the name. \nNo need for file extension/frame padding as it will copy whatever you have on your input sequence" -STARTLINE}
render_name some_name
addUserKnob {6 skip_directory_checks l "Skip directory check" t "If this is selected - there will be no popup asking ifyou are sure the directory is correct" +STARTLINE}
addUserKnob {26 text_3 l "  " T " "}
addUserKnob {26 text_1 l "Model parameters" T "\n"}
addUserKnob {26 text l " "}
addUserKnob {4 model_to_run l "Model to run" t "Sam - SegmentAnything2 (META)\nDAM -  DistractorAwareMemory for SAM2" M {sam sam3 dam depth_crafter depth_anything3 rgb2x cotracker ml-sharp "" "" "" "" "" ""}}
model_to_run sam3
addUserKnob {6 use_gdino l "Use semantic detection" t "If enabled, it will try to find in the reference frame the id class defined by the user." -STARTLINE +HIDDEN}
addUserKnob {6 use_sam3 l "Sam3 semantic detection" -STARTLINE +HIDDEN}
use_sam3 true
addUserKnob {6 use_grid l "track everything" -STARTLINE +HIDDEN}
addUserKnob {3 grid_size l "grid size" t "Number of points to spawn in grid. Capped at 40x40" +HIDDEN}
grid_size 40
addUserKnob {6 single_frame_mode l "Single frame mode" +HIDDEN +STARTLINE}
addUserKnob {3 focal_lenght l "Focal lenght (mm)" +HIDDEN}
focal_lenght 35
addUserKnob {30 film_back_size l "Film Back size" +HIDDEN}
film_back_size {36 24}
addUserKnob {3 max_grid_value +INVISIBLE}
max_grid_value 40
addUserKnob {1 id_class l "id class" t "What to segment when using semantic detection"}
addUserKnob {15 crop_position l "crop position" +HIDDEN}
crop_position {20 512 520 1012}
addUserKnob {3 frame_idx l "reference frame"}
frame_idx 30
addUserKnob {22 fetch_frame l "fetch frame" -STARTLINE T "frame = nuke.frame() if nuke.frame() >= nuke.thisNode()\['firstFrame'].value() else nuke.thisNode()\['firstFrame'].value()\nframe = frame if frame <= nuke.thisNode()\['lastFrame'].value() else nuke.thisNode()\['lastFrame'].value()\nframe = int(frame)\nnuke.thisNode()\['frame_idx'].setValue(frame)"}
addUserKnob {6 all_passes l "all passes" +HIDDEN +STARTLINE}
all_passes true
addUserKnob {6 albedo -STARTLINE +HIDDEN}
addUserKnob {6 normal -STARTLINE +HIDDEN}
addUserKnob {6 roughness +HIDDEN +STARTLINE}
addUserKnob {6 metallic -STARTLINE +HIDDEN}
addUserKnob {6 irradiance -STARTLINE +HIDDEN}
addUserKnob {22 addcrop l "add crop" +INVISIBLE +STARTLINE}
addUserKnob {3 firstFrame l integer +INVISIBLE}
firstFrame {{input.first_frame}}
addUserKnob {3 lastFrame l integer -STARTLINE +INVISIBLE}
lastFrame {{input.last_frame}}
addUserKnob {26 ""}
addUserKnob {22 writeconfig l "write config" t "Write config file to server listening location" T "######################################################################\n# Copyright (c) 2025 Luca Prestini\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#     http://www.apache.org/licenses/LICENSE-2.0\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n######################################################################\n\n\nimport json\nimport os\nimport threading\nimport uuid\nimport nuke\nimport nukescripts\nimport time\n\n\n\nif nuke.NUKE_VERSION_MAJOR > 15:\n    from PySide6 import QtWidgets\n\n\n    # from PySide6.QtWidgets import QPushButton, QSizePolicy\n    from PySide6.QtCore import QObject, QEvent\nelse:\n    from PySide2 import QtWidgets\n    from PySide2.QtCore import QObject, QEvent\n\n\nIS_17 = nuke.NUKE_VERSION_MAJOR >= 17\n\n\ndef cancel_task():\n    config_save_directory = node\[\"render_to\"].value()\n    with open(os.path.join(config_save_directory, \"cancel_render\"), \"w\") as f:\n        f.write(\"cancel\")\n\n\n\ndef run_progress_bar(path_to_file, model_type):\n    task = nuke.ProgressTask(\"Please wait...\")\n\n\n    spinner = \[\"-\", \"\\\\\", \"|\", \"/\"]\n    i = 0\n\n\n    in_progress = True\n    filename = None\n    render_progress = 0\n    progress = 0\n    tracking_progress = 0\n    while in_progress:\n        if task.isCancelled():\n            nuke.message(\"Cancelled!\")\n            task.setProgress(100)\n            cancel_task()\n            return False\n\n\n        if os.path.isfile(path_to_file):\n            try:\n                with open(path_to_file, \"r\") as f:\n                    cfg = json.load(f)\n\n\n                render_progress = cfg\[\"render_progress\"]\n                tracking_progress = cfg\[\"tracking_progress\"]\n                filename = cfg\[\"filename\"]\n                error = cfg\[\"error\"]\n                error_msg = cfg\[\"error_msg\"]\n            except Exception:\n                pass\n\n\n            if error:\n                task.setProgress(100)\n                nuke.message(\n                    \"Sorry I bumped into an error. Cancelling now. You can read the error in the terminal/script editor\"\n                )\n                print(error_msg)\n                nuke.tprint(error_msg)\n                return False\n\n\n            progress = int(\n                (\n                    int(render_progress.replace(\"%\", \"\"))\n                    + int(tracking_progress.replace(\"%\", \"\"))\n                )\n                / 2\n            )\n\n\n        task.setProgress((progress % 100))\n        task.setMessage(f\"Processing \{model_type\} \{spinner\[i % 4]\}\")\n\n\n        time.sleep(0.2)\n\n\n        i += 1\n        in_progress = render_progress != \"100%\"\n        if not in_progress:\n            break\n    task.setProgress(100)\n\n\n    return filename\n\n\n\ndef remove_from_queue(node, path):\n    queue = node\[\"queue\"].value().split(\",\")\n    queue.pop(0)\n    node\[\"queue\"].setValue(\",\".join(i for i in queue))\n    if os.path.isfile(path):\n        os.remove(path)\n\n\n\nclass UserActivityMonitor(QObject):\n    def __init__(self, idle_timeout=1):  # milliseconds\n        super().__init__()\n        self.last_activity_time = time.time()\n        self.idle_timeout = idle_timeout / 1000  # convert to seconds\n\n\n    def eventFilter(self, obj, event):\n        if event.type() in (QEvent.KeyPress, QEvent.MouseMove, QEvent.MouseButtonPress):\n            self.last_activity_time = time.time()\n        return super().eventFilter(obj, event)\n\n\n    def is_user_idle(self):\n        return (time.time() - self.last_activity_time) > self.idle_timeout\n\n\n\nclass CustomTimer(threading.Thread):\n    def __init__(self, interval, function, args=None, kwargs=None):\n        super().__init__()\n        self.interval = interval\n        self.function = function\n        self.args = args or \[]\n        self.kwargs = kwargs or \{\}\n        self._stop_event = threading.Event()\n        self.has_created = False\n\n\n    def run(self):\n        if not self._stop_event.wait(self.interval):\n            self.has_created = self.function(*self.args, **self.kwargs)\n        if self.has_created:\n            self.cancel()\n\n\n    def cancel(self):\n        self._stop_event.set()\n\n\n\nclass Loader(object):\n    def __init__(self, node, path, print_to_terminal=True, is_tracker=False, is_gs = True):\n        self.node = node\n        self.path = path\n        self.print_to_terminal = print_to_terminal\n        self.is_tracker = is_tracker\n        self.is_gs = is_gs\n        self.timer = CustomTimer(\n            10,\n            self.load_bg_render,\n            \[self.node, self.path, self.print_to_terminal, self.is_tracker],\n        )\n        self.timer.start()\n        self.timer_completed = False\n        self.user_monitor = UserActivityMonitor()\n        app = QtWidgets.QApplication.instance()\n        app.installEventFilter(self.user_monitor)\n\n\n    def setup_read(self, file_list, node):\n        \"\"\"Function to create the read node. Have to use this as a workaround as I cant simply do nuke.nodes.Read() with threading.Timer as it crashes nuke\"\"\"\n\n\n        reads = \[i for i in nuke.allNodes(\"Read\")]\n        read_no = (\n            max(\n                \[\n                    int(i\[\"name\"].value().replace(\"Read\", \"\"))\n                    for i in reads\n                    if \"MLRunner\" not in i.name()\n                ]\n            )\n            + 1\n        )\n        template_node = \"\"\"Read \{\n            name template_name\n            file template_file\n            first template_first\n            last template_last\n            file_type png\n            xpos template_xpos\n            ypos template_ypos\n            \}\"\"\"\n        if \" \" in file_list:\n            name, frame_range = file_list.split(\" \")\n            first, last = frame_range.split(\"-\")\n            xpos = node.xpos() + 150\n            ypos = node.ypos()\n            template_node = (\n                template_node.replace(\"template_file\", name)\n                .replace(\"template_first\", first)\n                .replace(\"template_last\", last)\n                .replace(\"template_name\", \"Read\" + str(read_no))\n                .replace(\"template_xpos\", str(xpos))\n                .replace(\"template_ypos\", str(ypos))\n            )\n            nuke.tcl(\"in root \{%s\}\" % template_node)\n            time.sleep(0.2)\n\n\n    def setup_geo_import(self, file_path, node):\n        \"\"\"Function to create the read node. Have to use this as a workaround as I cant simply do nuke.nodes.Read() with threading.Timer as it crashes nuke\"\"\"\n\n\n        reads = \[i for i in nuke.allNodes(\"GeoImport\")]\n        read_no = (\n            max(\n                \[\n                    int(i\[\"name\"].value().replace(\"GeoImport\", \"\"))\n                    for i in reads\n                    if \"MLRunner\" not in i.name()\n                ]\n            )\n            + 1\n        )\n        template_node = \"\"\"GeoImport \{\n            name template_name\n            file template_file\n            xpos template_xpos\n            ypos template_ypos\n            \}\"\"\"\n        xpos = node.xpos() + 150\n        ypos = node.ypos()\n        template_node = (\n            template_node.replace(\"template_file\", file_path)\n            .replace(\"template_name\", \"GeoImport\" + str(read_no))\n            .replace(\"template_xpos\", str(xpos))\n            .replace(\"template_ypos\", str(ypos))\n        )\n        nuke.tcl(\"in root \{%s\}\" % template_node)\n        time.sleep(0.2)\n\n\n    def load_bg_render(self, node, path, print_to_terminal, is_tracker):\n        if not self.timer_completed:\n            self.timer = CustomTimer(\n                10,\n                self.load_bg_render,\n                \[self.node, self.path, self.print_to_terminal, self.is_tracker],\n            )\n            self.timer.start()\n        else:\n            self.timer.cancel()\n\n\n        if os.path.isfile(self.path):\n            # Read json\n            with open(self.path, \"r\") as f:\n                file = json.load(f)\n            name = file\[\"name\"]\n            tracking = file\[\"tracking_progress\"]\n            render_p = file\[\"render_progress\"]\n            filename = file\[\"filename\"]\n            error = file\[\"error\"]\n            cancelled = file\[\"is_cancelled\"]\n            error_msg = file\[\"error_msg\"]\n\n\n            # Check if file is the first in queue\n            queue = self.node\[\"queue\"].value().split(\",\")\n            queue = queue if len(queue) >= 1 else \[name]\n            correct_queue = True if name == queue\[0] else False\n            self.timer_completed = False\n\n\n            # Update progress\n            if correct_queue:\n                # This is a little buggy as nuke UI doens't always update\n                filler = f\"name: \{name\}\\ntracking progress: \{tracking\}\\nrender_progress: \{render_p\}\"\n                self.node\[\"render_progress\"].setValue(filler)\n                if self.print_to_terminal:\n                    nuke.tprint(filler)\n\n\n            # Stop timer\n            if render_p == \"100%\" or error or cancelled:\n                remove_from_queue(self.node, self.path)\n                self.timer_completed = True\n                # Need to implement error behaviour\n\n\n            # Load rendered element in nuke\n            if self.timer_completed and not error and not cancelled:\n                # Need to check if user is doing stuf as it can crash nuke if we create nodes while user interacts with UI\n                max_count = 40\n                count = 0\n                while count <= max_count:\n                    if self.user_monitor.is_user_idle():\n                        if not self.is_tracker and not self.is_gs:\n                            if self.user_monitor.is_user_idle():\n                                for _file in filename:\n                                    shot = \[\n                                        i\n                                        for i in nuke.getFileNameList(\n                                            os.path.dirname(self.path)\n                                        )\n                                        if _file in i\n                                    ]\n                                    if shot:\n                                        self.setup_read(\n                                            os.path.join(\n                                                os.path.dirname(self.path), shot\[0]\n                                            ).replace(\"\\\\\", \"/\"),\n                                            self.node,\n                                        )\n                                count = 40\n                        elif self.is_gs:\n                            if self.user_monitor.is_user_idle():\n                                for _file in filename:\n                                    splat_path = os.path.join(os.path.join(os.path.dirname(self.path), _file)).replace(\"\\\\\", \"/\")\n                                    if IS_17:\n                                        self.setup_geo_import(splat_path,\n                                            self.node,\n                                        )\n                                    else:\n                                        print(f'I cant load the splats in any version less than Nuke17, rendered splats at:\\n\{splat_path\}')\n                                count = 40\n                        else:\n                            if self.user_monitor.is_user_idle():\n                                for _file in filename:\n                                    with open(\n                                        os.path.join(os.path.dirname(self.path), _file),\n                                        \"r\",\n                                    ) as f:\n                                        nuke.tcl(\"in root \{%s\}\" % f.read())\n                                count = 40\n                    count += 1\n            elif self.timer_completed and error:\n                print(\n                    f\"There was en while processing. Here is the message: \{error_msg\}\"\n                )\n\n\n        return self.timer_completed\n\n\n\ndef ensure_legal_crop_size(crop_val, width, height):\n    box = \[]\n    for idx, i in enumerate(crop_val):\n        if i < 0:\n            i = 0\n        elif i > width and idx == 2:\n            i = width\n        elif i > height and idx == 3:\n            i = height\n        box.append(i)\n    return box\n\n\n\ndef ensure_legal_frame(current_frame, first, last):\n    frame = current_frame if current_frame > first else first\n    frame = current_frame if current_frame < last else last\n    return frame\n\n\n\ndef padding_to_num(padded_name, delimiter, ref_frame):\n    pad, ext = os.path.splitext(padded_name)\n    pad = pad.split(delimiter)\[-1]\n    pad = pad.replace(\"%0\", \"\").replace(\"d\", \"\")\n    pad = int(pad) - len(str(ref_frame))\n    pads = \"\".join(\"0\" for i in range(int(pad)))\n    return pads\n\n\n\nnode = nuke.thisNode()\nconfig_save_directory = node\[\"config_save_directory\"].value()\nshot_name = node\[\"shot_name\"].value()\nwidth = node.width()\nheight = node.height()\ndelimiter = node\[\"delimiter\"].value()\nframe_idx = int(\n    node\[\"frame_idx\"].value()\n)  # ensure_legal_frame(int(node\['frame_idx'].value()), int(node.firstFrame()), int(node.lastFrame()))\n\n\n\n# Check all is good\nis_correct_extension = any(\n    shot_name.split(\".\")\[-1].lower() in i\n    for i in (\".png\", \".jpg\", \".jpeg\", \".exr\", \".mov\")\n)\nis_mov = \"mov\" in os.path.splitext(shot_name)\[-1].lower()\npath_to_sequence_exists = os.path.isdir(node\[\"path_to_sequence\"].value())\nis_node_connected = len(node.dependencies()) > 0\nis_segmentation = node\[\"model_to_run\"].value() in (\"sam\", \"dam\", \"sam3\")\nis_tracking = node\[\"model_to_run\"].value() == \"cotracker\"\nis_gs = node\[\"model_to_run\"].value() == \"ml-sharp\"\nuse_sam3 = node\[\"use_sam3\"].value() if node\[\"model_to_run\"].value() == \"sam3\" else False\nFG_render = node\[\"fg_render\"].value()\nis_single_frame_mode = node\[\"single_frame_mode\"].value() and is_gs\n\n\n\nif is_segmentation or is_tracking:\n    is_frame_legal = frame_idx >= int(node.firstFrame()) and frame_idx <= int(\n        node.lastFrame()\n    )\n    if node\[\"use_limit\"].value():\n        is_frame_legal = frame_idx >= int(\n            node\[\"limit_first\"].value()\n        ) and frame_idx <= int(node\[\"limit_last\"].value())\nelse:\n    frame_idx = (\n        int(node.firstFrame())\n        if not node\[\"use_limit\"].value()\n        else int(node\[\"limit_first\"].value())\n    )\n    is_frame_legal = True\n\n\nconfig_dir_exists = os.path.isdir(config_save_directory)\nis_server_running = os.path.isfile(\n    os.path.join(config_save_directory, \".server_is_running.tmp\").replace(\"\\\\\", \"/\")\n)\n\n\n\nall_good = False\nif all(\n    i\n    for i in (\n        is_correct_extension,\n        path_to_sequence_exists,\n        is_node_connected,\n        is_frame_legal,\n        config_dir_exists,\n        is_server_running,\n    )\n):\n    all_good = True\nelse:\n    errors = \[\n        idx\n        for idx, i in enumerate(\n            (\n                is_correct_extension,\n                path_to_sequence_exists,\n                is_node_connected,\n                is_frame_legal,\n                config_dir_exists,\n                is_server_running,\n            )\n        )\n        if not i\n    ]\n    error_keys = \[\n        \"unsupported_extension\",\n        \"wrong_path\",\n        \"node_not_connected\",\n        \"wrong_frame\",\n        \"wrong_config_path\",\n        \"server_not_running\",\n    ]\n\n\n\nerror_messages = \{\n    \"unsupported_extension\": \"ERROR! The sequence you are trying to run does not have the correct file extension. We only support png and jpg for now.\\n\",\n    \"wrong_path\": \"ERROR! The path to the sequence doesnt seem to exists. Please check for spelling mistakes or use the Fetch Path shot button\\n\",\n    \"node_not_connected\": \"ERROR! Please connect the node to the sequence you want to run\\n\",\n    \"wrong_frame\": \"ERROR! The reference frame is outside the range of the sequence\\n\",\n    \"wrong_config_path\": f\"ERROR! The path defined in the Server listenting directory knob doesn't seem to exist! Please check for spelling mistakes!\\n \{config_save_directory\}\\n\",\n    \"server_not_running\": f\"ERROR! The server does't seem to be running. \\nPlease contact your administrator or ensure that the server is listenting in the same directory as what's specified in the node:\\n\{config_save_directory\}\\n\",\n\}\n\n\n\nif all_good:\n    crop_position = ensure_legal_crop_size(node\[\"crop_position\"].value(), width, height)\n    ## Setup config file\n    config = \{\}\n    config\[\"listen_dir\"] = config_save_directory\n    config\[\"model_to_run\"] = node\[\"model_to_run\"].value()\n    config\[\"id_class\"] = node\[\"id_class\"].value() if node\[\"id_class\"].visible() else \"\"\n    config\[\"crop_position\"] = (\n        \[crop_position] if node\[\"crop_position\"].visible() else None\n    )\n    config\[\"path_to_sequence\"] = node\[\"path_to_sequence\"].value()\n    config\[\"shot_name\"] = shot_name\n    config\[\"render_to\"] = node\[\"render_to\"].value()\n    config\[\"render_name\"] = node\[\"render_name\"].value()\n    config\[\"use_gdino\"] = node\[\"use_gdino\"].value()\n    config\[\"use_sam3\"] = use_sam3\n    config\[\"is_mov\"] = is_mov\n    config\[\"mov_last_frame\"] = int(node.lastFrame() - node.firstFrame())\n    config\[\"frame_idx\"] = int(frame_idx - node.firstFrame())\n    config\[\"first_frame_sequence\"] = int(node.firstFrame())\n    config\[\"limit_range\"] = node\[\"use_limit\"].value()\n    config\[\"delimiter\"] = delimiter\n    config\[\"use_grid\"] = node\[\"use_grid\"].value()\n    config\[\"grid_size\"] = node\[\"grid_size\"].value()\n    config\[\"focal_lenght\"] = node\[\"focal_lenght\"].value()\n    config\[\"film_back_size\"] = node\[\"film_back_size\"].value()\n    config\[\"single_frame_mode\"] = is_single_frame_mode\n    config\[\"colourspace\"] = (\n        \"linear\" if node\[\"model_to_run\"].value() == \"rgb2x\" else \"srgb\"\n    )\n    config\[\"passes\"] = \[\"albedo\", \"roughness\", \"metallic\", \"normal\", \"irradiance\"]\n    if not node\[\"all_passes\"].value():\n        pass_knobs = config\[\"passes\"]\n        config\[\"passes\"] = \[i for i in pass_knobs if node\[i].value()]\n\n\n    # Not implemented yet\n    config\[\"multisequence\"] = False\n\n\n    # We remove one frame as we are using these to simply slice lists\n    config\[\"limit_first\"] = int(node\[\"limit_first\"].value() - node.firstFrame())\n    config\[\"limit_last\"] = int(node\[\"limit_last\"].value() - node.firstFrame()) + 1\n\n\n    # In single frame mode we always only use one frame - this is an easy hack\n    if is_single_frame_mode:\n        config\[\"limit_first\"] = int(frame_idx - node.firstFrame())\n        config\[\"limit_last\"] = int(frame_idx - node.firstFrame()) + 1\n        config\['limit_range'] = True\n    else:\n        # If not single mode - we dont use annotation indx so it should be the first frame\n        config\['frame_idx'] = int(node.firstFrame())\n\n\n    # Write related stuff\n    write_sequence = node\[\"write_sequence\"].value()\n    write = nuke.toNode(f\"\{node.name()\}.Write1\")\n    # Workaround to evaluate padding\n    write\[\"file\"].setValue(shot_name)\n    shot_name_no_padding = os.path.basename(write\[\"file\"].evaluate())\n\n\n    ## When using pipelines evaluate is returning the path of the sequence. This is a hacky workaround.\n    if os.path.isdir(shot_name_no_padding):\n        shot_name_no_padding = padding_to_num(shot_name, delimiter, int(frame_idx))\n    config\[\"shot_name\"] = shot_name_no_padding\n\n\n    if not os.path.isdir(config\[\"render_to\"]):\n        os.makedirs(config\[\"render_to\"])\n\n\n    # If render sequence we write to path_to_sequence\n    if write_sequence:\n        write\[\"file\"].setValue(\n            os.path.join(node\[\"path_to_sequence\"].value(), shot_name).replace(\"\\\\\", \"/\")\n        )\n        nukescripts.render_panel((nuke.thisNode(),), False)\n\n\n    ## Write config\n    keep_going = False\n    if not node\[\"skip_directory_checks\"].value():\n        _render_dir = config\[\"render_to\"]\n        if nuke.ask(\n            f\"Hey! Just checking that you are happy with the render location. This is where I am going to render your file. \{_render_dir\}\"\n        ):\n            keep_going = True\n    else:\n        keep_going = True\n\n\n    if keep_going:\n        unique_name = str(uuid.uuid4())\n        config\[\"uuid\"] = unique_name\n        with open(\n            os.path.join(\n                config_save_directory, f\"\{unique_name\}_\{shot_name_no_padding\}.json\"\n            ).replace(\"\\\\\", \"/\"),\n            \"w\",\n        ) as f:\n            json.dump(config, f, indent=4)\n\n\n        queue = node\[\"queue\"].value()\n        queue = queue + \",\" + unique_name if queue != \"\" else unique_name\n        node\[\"queue\"].setValue(queue)\n        render_progress_file = os.path.join(\n            config\[\"render_to\"], f\"\{unique_name\}_render_progress.json\"\n        ).replace(\"\\\\\", \"/\")\n        if FG_render:\n            nuke.thisNode().end()\n            filename = run_progress_bar(render_progress_file, config\[\"model_to_run\"])\n            if filename:\n                if not is_tracking and not is_gs:\n                    for read_idx, _file in enumerate(filename):\n                        shot = \[\n                            i\n                            for i in nuke.getFileNameList(\n                                os.path.dirname(render_progress_file)\n                            )\n                            if _file in i\n                        ]\n                        if shot:\n                            read = nuke.nodes.Read()\n                            read\[\"file\"].fromUserText(\n                                os.path.join(\n                                    os.path.dirname(render_progress_file), shot\[0]\n                                ).replace(\"\\\\\", \"/\")\n                            )\n                            read.setXYpos(\n                                node.xpos() + (100 * (read_idx + 1)), node.ypos()\n                            )\n                elif is_gs:\n                    if IS_17:\n                        for gs_idx, _file in enumerate(filename):\n                            geo_import = nuke.nodes.GeoImport()\n                            geo_import\[\"file\"].setValue(os.path.join(os.path.dirname(render_progress_file), _file).replace(\"\\\\\", \"/\"))\n                            geo_import.setXYpos(\n                                node.xpos() + (100 * (gs_idx + 1)), node.ypos()\n                            )\n                    else:\n                        path_to_splat = os.path.dirname(render_progress_file)\n                        nuke.message(f'Your GS are ready! I cant import them in nuke as this isnt Nuke17! They are rendered at:\\n\{path_to_splat\}')\n                else:\n                    for tracker_idx, _file in enumerate(filename):\n                        tracker = nuke.loadToolset(\n                            os.path.join(os.path.dirname(render_progress_file), _file)\n                        )\n                        tracker.setXYpos(\n                            node.xpos() + (100 * (tracker_idx + 1)), node.ypos()\n                        )\n\n\n            remove_from_queue(node, render_progress_file)\n\n\n        else:\n            node_loader = Loader(node, render_progress_file, is_tracker=is_tracking, is_gs=is_gs)\nelse:\n    error_message = \"\\n\".join(error_messages\[error_keys\[i]] for i in errors)\n    nuke.alert(\n        f\"The following errors where found. Please ensure they are all fixed prior to writing the config:\\n\{error_message\}\"\n    )\n\n" +STARTLINE}
addUserKnob {6 write_sequence -STARTLINE +INVISIBLE}
addUserKnob {22 cancel_render l "cancel render" t "Interrupts model processing" -STARTLINE T "import json\nimport os\nimport uuid\nimport nuke\nimport nukescripts\n\n\n\nnode = nuke.thisNode()\nconfig_save_directory = node\['render_to'].value()\n\n\n\nwith open(os.path.join(config_save_directory, 'cancel_render'),'w') as f:\n    f.write('cancel')"}
addUserKnob {6 fg_render l "Use progress bar" -STARTLINE}
fg_render true
addUserKnob {26 render_progress l "Background progress" T "name: none\ntracking progress: 0%\nrender_progress: 0%"}
addUserKnob {1 queue +INVISIBLE}
}
Input {
inputs 0
name Input1
xpos 486
ypos -268
}
Write {
file some_shot.%04d.png
file_type png
create_directories true
checkHashOnRead false
version 10
in_colorspace scene_linear
out_colorspace scene_linear
ocioColorspace scene_linear
display default
view sRGB
name Write1
xpos 390
ypos -160
}
Output {
name Output1
xpos 390
ypos -60
}
end_group
